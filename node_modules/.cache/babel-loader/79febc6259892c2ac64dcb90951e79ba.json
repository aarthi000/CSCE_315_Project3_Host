{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BufferReader = void 0;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass BufferReader {\n  constructor() {\n    let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.offset = offset;\n    this.buffer = emptyBuffer;\n    // TODO(bmc): support non-utf8 encoding?\n    this.encoding = 'utf-8';\n  }\n  setBuffer(offset, buffer) {\n    this.offset = offset;\n    this.buffer = buffer;\n  }\n  int16() {\n    const result = this.buffer.readInt16BE(this.offset);\n    this.offset += 2;\n    return result;\n  }\n  byte() {\n    const result = this.buffer[this.offset];\n    this.offset++;\n    return result;\n  }\n  int32() {\n    const result = this.buffer.readInt32BE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  string(length) {\n    const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);\n    this.offset += length;\n    return result;\n  }\n  cstring() {\n    const start = this.offset;\n    let end = start;\n    while (this.buffer[end++] !== 0) {}\n    this.offset = end;\n    return this.buffer.toString(this.encoding, start, end - 1);\n  }\n  bytes(length) {\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return result;\n  }\n}\nexports.BufferReader = BufferReader;","map":{"version":3,"mappings":";;;;;;AAAA,MAAMA,WAAW,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;AAEzC,MAAaC,YAAY;EAMvBC,cAAsC;IAAA,IAAlBC,6EAAiB,CAAC;IAAlB,WAAM,GAANA,MAAM;IALlB,WAAM,GAAWL,WAAW;IAEpC;IACQ,aAAQ,GAAW,OAAO;EAEO;EAElCM,SAAS,CAACD,MAAc,EAAEE,MAAc;IAC7C,IAAI,CAACF,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,MAAM,GAAGA,MAAM;EACtB;EAEOC,KAAK;IACV,MAAMC,MAAM,GAAG,IAAI,CAACF,MAAM,CAACG,WAAW,CAAC,IAAI,CAACL,MAAM,CAAC;IACnD,IAAI,CAACA,MAAM,IAAI,CAAC;IAChB,OAAOI,MAAM;EACf;EAEOE,IAAI;IACT,MAAMF,MAAM,GAAG,IAAI,CAACF,MAAM,CAAC,IAAI,CAACF,MAAM,CAAC;IACvC,IAAI,CAACA,MAAM,EAAE;IACb,OAAOI,MAAM;EACf;EAEOG,KAAK;IACV,MAAMH,MAAM,GAAG,IAAI,CAACF,MAAM,CAACM,WAAW,CAAC,IAAI,CAACR,MAAM,CAAC;IACnD,IAAI,CAACA,MAAM,IAAI,CAAC;IAChB,OAAOI,MAAM;EACf;EAEOK,MAAM,CAACC,MAAc;IAC1B,MAAMN,MAAM,GAAG,IAAI,CAACF,MAAM,CAACS,QAAQ,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACZ,MAAM,EAAE,IAAI,CAACA,MAAM,GAAGU,MAAM,CAAC;IACrF,IAAI,CAACV,MAAM,IAAIU,MAAM;IACrB,OAAON,MAAM;EACf;EAEOS,OAAO;IACZ,MAAMC,KAAK,GAAG,IAAI,CAACd,MAAM;IACzB,IAAIe,GAAG,GAAGD,KAAK;IACf,OAAO,IAAI,CAACZ,MAAM,CAACa,GAAG,EAAE,CAAC,KAAK,CAAC,EAAE;IACjC,IAAI,CAACf,MAAM,GAAGe,GAAG;IACjB,OAAO,IAAI,CAACb,MAAM,CAACS,QAAQ,CAAC,IAAI,CAACC,QAAQ,EAAEE,KAAK,EAAEC,GAAG,GAAG,CAAC,CAAC;EAC5D;EAEOC,KAAK,CAACN,MAAc;IACzB,MAAMN,MAAM,GAAG,IAAI,CAACF,MAAM,CAACe,KAAK,CAAC,IAAI,CAACjB,MAAM,EAAE,IAAI,CAACA,MAAM,GAAGU,MAAM,CAAC;IACnE,IAAI,CAACV,MAAM,IAAIU,MAAM;IACrB,OAAON,MAAM;EACf;;AAjDFc","names":["emptyBuffer","Buffer","allocUnsafe","BufferReader","constructor","offset","setBuffer","buffer","int16","result","readInt16BE","byte","int32","readInt32BE","string","length","toString","encoding","cstring","start","end","bytes","slice","exports"],"sources":["C:\\Users\\aarth\\Documents\\CollegeFall23\\CSCE315\\CSCE_315_Project3\\node_modules\\pg-protocol\\src\\buffer-reader.ts"],"sourcesContent":["const emptyBuffer = Buffer.allocUnsafe(0)\n\nexport class BufferReader {\n  private buffer: Buffer = emptyBuffer\n\n  // TODO(bmc): support non-utf8 encoding?\n  private encoding: string = 'utf-8'\n\n  constructor(private offset: number = 0) {}\n\n  public setBuffer(offset: number, buffer: Buffer): void {\n    this.offset = offset\n    this.buffer = buffer\n  }\n\n  public int16(): number {\n    const result = this.buffer.readInt16BE(this.offset)\n    this.offset += 2\n    return result\n  }\n\n  public byte(): number {\n    const result = this.buffer[this.offset]\n    this.offset++\n    return result\n  }\n\n  public int32(): number {\n    const result = this.buffer.readInt32BE(this.offset)\n    this.offset += 4\n    return result\n  }\n\n  public string(length: number): string {\n    const result = this.buffer.toString(this.encoding, this.offset, this.offset + length)\n    this.offset += length\n    return result\n  }\n\n  public cstring(): string {\n    const start = this.offset\n    let end = start\n    while (this.buffer[end++] !== 0) {}\n    this.offset = end\n    return this.buffer.toString(this.encoding, start, end - 1)\n  }\n\n  public bytes(length: number): Buffer {\n    const result = this.buffer.slice(this.offset, this.offset + length)\n    this.offset += length\n    return result\n  }\n}\n"]},"metadata":{},"sourceType":"script"}