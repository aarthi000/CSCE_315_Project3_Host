{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\nconst messages_1 = require(\"./messages\");\nconst buffer_reader_1 = require(\"./buffer-reader\");\nconst assert_1 = __importDefault(require(\"assert\"));\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass Parser {\n  constructor(opts) {\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n  parse(buffer, callback) {\n    this.mergeBuffer(buffer);\n    const bufferFullLength = this.bufferOffset + this.bufferLength;\n    let offset = this.bufferOffset;\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset];\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n      const fullMessageLength = CODE_LENGTH + length;\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n        callback(message);\n        offset += fullMessageLength;\n      } else {\n        break;\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer;\n      this.bufferLength = 0;\n      this.bufferOffset = 0;\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset;\n      this.bufferOffset = offset;\n    }\n  }\n  mergeBuffer(buffer) {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength;\n      const newFullLength = newLength + this.bufferOffset;\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer;\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer;\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2;\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2;\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength);\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n        this.buffer = newBuffer;\n        this.bufferOffset = 0;\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n      this.bufferLength = newLength;\n    } else {\n      this.buffer = buffer;\n      this.bufferOffset = 0;\n      this.bufferLength = buffer.byteLength;\n    }\n  }\n  handlePacket(offset, code, length, bytes) {\n    switch (code) {\n      case 50 /* BindComplete */:\n        return messages_1.bindComplete;\n      case 49 /* ParseComplete */:\n        return messages_1.parseComplete;\n      case 51 /* CloseComplete */:\n        return messages_1.closeComplete;\n      case 110 /* NoData */:\n        return messages_1.noData;\n      case 115 /* PortalSuspended */:\n        return messages_1.portalSuspended;\n      case 99 /* CopyDone */:\n        return messages_1.copyDone;\n      case 87 /* ReplicationStart */:\n        return messages_1.replicationStart;\n      case 73 /* EmptyQuery */:\n        return messages_1.emptyQuery;\n      case 68 /* DataRow */:\n        return this.parseDataRowMessage(offset, length, bytes);\n      case 67 /* CommandComplete */:\n        return this.parseCommandCompleteMessage(offset, length, bytes);\n      case 90 /* ReadyForQuery */:\n        return this.parseReadyForQueryMessage(offset, length, bytes);\n      case 65 /* NotificationResponse */:\n        return this.parseNotificationMessage(offset, length, bytes);\n      case 82 /* AuthenticationResponse */:\n        return this.parseAuthenticationResponse(offset, length, bytes);\n      case 83 /* ParameterStatus */:\n        return this.parseParameterStatusMessage(offset, length, bytes);\n      case 75 /* BackendKeyData */:\n        return this.parseBackendKeyData(offset, length, bytes);\n      case 69 /* ErrorMessage */:\n        return this.parseErrorMessage(offset, length, bytes, 'error');\n      case 78 /* NoticeMessage */:\n        return this.parseErrorMessage(offset, length, bytes, 'notice');\n      case 84 /* RowDescriptionMessage */:\n        return this.parseRowDescriptionMessage(offset, length, bytes);\n      case 116 /* ParameterDescriptionMessage */:\n        return this.parseParameterDescriptionMessage(offset, length, bytes);\n      case 71 /* CopyIn */:\n        return this.parseCopyInMessage(offset, length, bytes);\n      case 72 /* CopyOut */:\n        return this.parseCopyOutMessage(offset, length, bytes);\n      case 100 /* CopyData */:\n        return this.parseCopyData(offset, length, bytes);\n      default:\n        assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n    }\n  }\n  parseReadyForQueryMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const status = this.reader.string(1);\n    return new messages_1.ReadyForQueryMessage(length, status);\n  }\n  parseCommandCompleteMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const text = this.reader.cstring();\n    return new messages_1.CommandCompleteMessage(length, text);\n  }\n  parseCopyData(offset, length, bytes) {\n    const chunk = bytes.slice(offset, offset + (length - 4));\n    return new messages_1.CopyDataMessage(length, chunk);\n  }\n  parseCopyInMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n  }\n  parseCopyOutMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n  }\n  parseCopyMessage(offset, length, bytes, messageName) {\n    this.reader.setBuffer(offset, bytes);\n    const isBinary = this.reader.byte() !== 0;\n    const columnCount = this.reader.int16();\n    const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16();\n    }\n    return message;\n  }\n  parseNotificationMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processId = this.reader.int32();\n    const channel = this.reader.cstring();\n    const payload = this.reader.cstring();\n    return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n  }\n  parseRowDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField();\n    }\n    return message;\n  }\n  parseField() {\n    const name = this.reader.cstring();\n    const tableID = this.reader.int32();\n    const columnID = this.reader.int16();\n    const dataTypeID = this.reader.int32();\n    const dataTypeSize = this.reader.int16();\n    const dataTypeModifier = this.reader.int32();\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n  }\n  parseParameterDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const parameterCount = this.reader.int16();\n    const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32();\n    }\n    return message;\n  }\n  parseDataRowMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const fields = new Array(fieldCount);\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32();\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len);\n    }\n    return new messages_1.DataRowMessage(length, fields);\n  }\n  parseParameterStatusMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const name = this.reader.cstring();\n    const value = this.reader.cstring();\n    return new messages_1.ParameterStatusMessage(length, name, value);\n  }\n  parseBackendKeyData(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processID = this.reader.int32();\n    const secretKey = this.reader.int32();\n    return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n  }\n  parseAuthenticationResponse(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const code = this.reader.int32();\n    // TODO(bmc): maybe better types here\n    const message = {\n      name: 'authenticationOk',\n      length\n    };\n    switch (code) {\n      case 0:\n        // AuthenticationOk\n        break;\n      case 3:\n        // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword';\n        }\n        break;\n      case 5:\n        // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password';\n          const salt = this.reader.bytes(4);\n          return new messages_1.AuthenticationMD5Password(length, salt);\n        }\n        break;\n      case 10:\n        // AuthenticationSASL\n        message.name = 'authenticationSASL';\n        message.mechanisms = [];\n        let mechanism;\n        do {\n          mechanism = this.reader.cstring();\n          if (mechanism) {\n            message.mechanisms.push(mechanism);\n          }\n        } while (mechanism);\n        break;\n      case 11:\n        // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue';\n        message.data = this.reader.string(length - 8);\n        break;\n      case 12:\n        // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal';\n        message.data = this.reader.string(length - 8);\n        break;\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code);\n    }\n    return message;\n  }\n  parseErrorMessage(offset, length, bytes, name) {\n    this.reader.setBuffer(offset, bytes);\n    const fields = {};\n    let fieldType = this.reader.string(1);\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring();\n      fieldType = this.reader.string(1);\n    }\n    const messageValue = fields.M;\n    const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n    message.severity = fields.S;\n    message.code = fields.C;\n    message.detail = fields.D;\n    message.hint = fields.H;\n    message.position = fields.P;\n    message.internalPosition = fields.p;\n    message.internalQuery = fields.q;\n    message.where = fields.W;\n    message.schema = fields.s;\n    message.table = fields.t;\n    message.column = fields.c;\n    message.dataType = fields.d;\n    message.constraint = fields.n;\n    message.file = fields.F;\n    message.line = fields.L;\n    message.routine = fields.R;\n    return message;\n  }\n}\nexports.Parser = Parser;","map":{"version":3,"mappings":"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","names":["CODE_LENGTH","LEN_LENGTH","HEADER_LENGTH","emptyBuffer","Buffer","allocUnsafe","Parser","constructor","opts","buffer_reader_1","mode","Error","parse","buffer","callback","mergeBuffer","bufferFullLength","bufferOffset","bufferLength","offset","code","length","readUInt32BE","fullMessageLength","message","handlePacket","newLength","byteLength","newFullLength","newBuffer","newBufferLength","copy","bytes","messages_1","parseDataRowMessage","parseCommandCompleteMessage","parseReadyForQueryMessage","parseNotificationMessage","parseAuthenticationResponse","parseParameterStatusMessage","parseBackendKeyData","parseErrorMessage","parseRowDescriptionMessage","parseParameterDescriptionMessage","parseCopyInMessage","parseCopyOutMessage","parseCopyData","assert_1","fail","toString","reader","setBuffer","status","string","text","cstring","chunk","slice","parseCopyMessage","messageName","isBinary","byte","columnCount","int16","i","columnTypes","processId","int32","channel","payload","fieldCount","fields","parseField","name","tableID","columnID","dataTypeID","dataTypeSize","dataTypeModifier","parameterCount","dataTypeIDs","Array","len","value","processID","secretKey","salt","mechanisms","mechanism","push","data","fieldType","messageValue","M","severity","S","C","detail","D","hint","H","position","P","internalPosition","p","internalQuery","q","where","W","schema","s","table","t","column","c","dataType","d","constraint","n","file","F","line","L","routine","R","exports"],"sources":["C:\\Users\\aarth\\Documents\\CollegeFall23\\CSCE315\\CSCE_315_Project3\\node_modules\\pg-protocol\\src\\parser.ts"],"sourcesContent":["import { TransformOptions } from 'stream'\nimport {\n  Mode,\n  bindComplete,\n  parseComplete,\n  closeComplete,\n  noData,\n  portalSuspended,\n  copyDone,\n  replicationStart,\n  emptyQuery,\n  ReadyForQueryMessage,\n  CommandCompleteMessage,\n  CopyDataMessage,\n  CopyResponse,\n  NotificationResponseMessage,\n  RowDescriptionMessage,\n  ParameterDescriptionMessage,\n  Field,\n  DataRowMessage,\n  ParameterStatusMessage,\n  BackendKeyDataMessage,\n  DatabaseError,\n  BackendMessage,\n  MessageName,\n  AuthenticationMD5Password,\n  NoticeMessage,\n} from './messages'\nimport { BufferReader } from './buffer-reader'\nimport assert from 'assert'\n\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4\n\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH\n\nexport type Packet = {\n  code: number\n  packet: Buffer\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\ntype StreamOptions = TransformOptions & {\n  mode: Mode\n}\n\nconst enum MessageCodes {\n  DataRow = 0x44, // D\n  ParseComplete = 0x31, // 1\n  BindComplete = 0x32, // 2\n  CloseComplete = 0x33, // 3\n  CommandComplete = 0x43, // C\n  ReadyForQuery = 0x5a, // Z\n  NoData = 0x6e, // n\n  NotificationResponse = 0x41, // A\n  AuthenticationResponse = 0x52, // R\n  ParameterStatus = 0x53, // S\n  BackendKeyData = 0x4b, // K\n  ErrorMessage = 0x45, // E\n  NoticeMessage = 0x4e, // N\n  RowDescriptionMessage = 0x54, // T\n  ParameterDescriptionMessage = 0x74, // t\n  PortalSuspended = 0x73, // s\n  ReplicationStart = 0x57, // W\n  EmptyQuery = 0x49, // I\n  CopyIn = 0x47, // G\n  CopyOut = 0x48, // H\n  CopyDone = 0x63, // c\n  CopyData = 0x64, // d\n}\n\nexport type MessageCallback = (msg: BackendMessage) => void\n\nexport class Parser {\n  private buffer: Buffer = emptyBuffer\n  private bufferLength: number = 0\n  private bufferOffset: number = 0\n  private reader = new BufferReader()\n  private mode: Mode\n\n  constructor(opts?: StreamOptions) {\n    if (opts?.mode === 'binary') {\n      throw new Error('Binary mode not supported yet')\n    }\n    this.mode = opts?.mode || 'text'\n  }\n\n  public parse(buffer: Buffer, callback: MessageCallback) {\n    this.mergeBuffer(buffer)\n    const bufferFullLength = this.bufferOffset + this.bufferLength\n    let offset = this.bufferOffset\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset]\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH)\n      const fullMessageLength = CODE_LENGTH + length\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer)\n        callback(message)\n        offset += fullMessageLength\n      } else {\n        break\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer\n      this.bufferLength = 0\n      this.bufferOffset = 0\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset\n      this.bufferOffset = offset\n    }\n  }\n\n  private mergeBuffer(buffer: Buffer): void {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength\n      const newFullLength = newLength + this.bufferOffset\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer: Buffer\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength)\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength)\n        this.buffer = newBuffer\n        this.bufferOffset = 0\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength)\n      this.bufferLength = newLength\n    } else {\n      this.buffer = buffer\n      this.bufferOffset = 0\n      this.bufferLength = buffer.byteLength\n    }\n  }\n\n  private handlePacket(offset: number, code: number, length: number, bytes: Buffer): BackendMessage {\n    switch (code) {\n      case MessageCodes.BindComplete:\n        return bindComplete\n      case MessageCodes.ParseComplete:\n        return parseComplete\n      case MessageCodes.CloseComplete:\n        return closeComplete\n      case MessageCodes.NoData:\n        return noData\n      case MessageCodes.PortalSuspended:\n        return portalSuspended\n      case MessageCodes.CopyDone:\n        return copyDone\n      case MessageCodes.ReplicationStart:\n        return replicationStart\n      case MessageCodes.EmptyQuery:\n        return emptyQuery\n      case MessageCodes.DataRow:\n        return this.parseDataRowMessage(offset, length, bytes)\n      case MessageCodes.CommandComplete:\n        return this.parseCommandCompleteMessage(offset, length, bytes)\n      case MessageCodes.ReadyForQuery:\n        return this.parseReadyForQueryMessage(offset, length, bytes)\n      case MessageCodes.NotificationResponse:\n        return this.parseNotificationMessage(offset, length, bytes)\n      case MessageCodes.AuthenticationResponse:\n        return this.parseAuthenticationResponse(offset, length, bytes)\n      case MessageCodes.ParameterStatus:\n        return this.parseParameterStatusMessage(offset, length, bytes)\n      case MessageCodes.BackendKeyData:\n        return this.parseBackendKeyData(offset, length, bytes)\n      case MessageCodes.ErrorMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'error')\n      case MessageCodes.NoticeMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'notice')\n      case MessageCodes.RowDescriptionMessage:\n        return this.parseRowDescriptionMessage(offset, length, bytes)\n      case MessageCodes.ParameterDescriptionMessage:\n        return this.parseParameterDescriptionMessage(offset, length, bytes)\n      case MessageCodes.CopyIn:\n        return this.parseCopyInMessage(offset, length, bytes)\n      case MessageCodes.CopyOut:\n        return this.parseCopyOutMessage(offset, length, bytes)\n      case MessageCodes.CopyData:\n        return this.parseCopyData(offset, length, bytes)\n      default:\n        assert.fail(`unknown message code: ${code.toString(16)}`)\n    }\n  }\n\n  private parseReadyForQueryMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const status = this.reader.string(1)\n    return new ReadyForQueryMessage(length, status)\n  }\n\n  private parseCommandCompleteMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const text = this.reader.cstring()\n    return new CommandCompleteMessage(length, text)\n  }\n\n  private parseCopyData(offset: number, length: number, bytes: Buffer) {\n    const chunk = bytes.slice(offset, offset + (length - 4))\n    return new CopyDataMessage(length, chunk)\n  }\n\n  private parseCopyInMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse')\n  }\n\n  private parseCopyOutMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse')\n  }\n\n  private parseCopyMessage(offset: number, length: number, bytes: Buffer, messageName: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const isBinary = this.reader.byte() !== 0\n    const columnCount = this.reader.int16()\n    const message = new CopyResponse(length, messageName, isBinary, columnCount)\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16()\n    }\n    return message\n  }\n\n  private parseNotificationMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processId = this.reader.int32()\n    const channel = this.reader.cstring()\n    const payload = this.reader.cstring()\n    return new NotificationResponseMessage(length, processId, channel, payload)\n  }\n\n  private parseRowDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const message = new RowDescriptionMessage(length, fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField()\n    }\n    return message\n  }\n\n  private parseField(): Field {\n    const name = this.reader.cstring()\n    const tableID = this.reader.int32()\n    const columnID = this.reader.int16()\n    const dataTypeID = this.reader.int32()\n    const dataTypeSize = this.reader.int16()\n    const dataTypeModifier = this.reader.int32()\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary'\n    return new Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode)\n  }\n\n  private parseParameterDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const parameterCount = this.reader.int16()\n    const message = new ParameterDescriptionMessage(length, parameterCount)\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32()\n    }\n    return message\n  }\n\n  private parseDataRowMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const fields: any[] = new Array(fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32()\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len)\n    }\n    return new DataRowMessage(length, fields)\n  }\n\n  private parseParameterStatusMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const name = this.reader.cstring()\n    const value = this.reader.cstring()\n    return new ParameterStatusMessage(length, name, value)\n  }\n\n  private parseBackendKeyData(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processID = this.reader.int32()\n    const secretKey = this.reader.int32()\n    return new BackendKeyDataMessage(length, processID, secretKey)\n  }\n\n  public parseAuthenticationResponse(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const code = this.reader.int32()\n    // TODO(bmc): maybe better types here\n    const message: BackendMessage & any = {\n      name: 'authenticationOk',\n      length,\n    }\n\n    switch (code) {\n      case 0: // AuthenticationOk\n        break\n      case 3: // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword'\n        }\n        break\n      case 5: // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password'\n          const salt = this.reader.bytes(4)\n          return new AuthenticationMD5Password(length, salt)\n        }\n        break\n      case 10: // AuthenticationSASL\n        message.name = 'authenticationSASL'\n        message.mechanisms = []\n        let mechanism: string\n        do {\n          mechanism = this.reader.cstring()\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism)\n          }\n        } while (mechanism)\n        break\n      case 11: // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue'\n        message.data = this.reader.string(length - 8)\n        break\n      case 12: // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal'\n        message.data = this.reader.string(length - 8)\n        break\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code)\n    }\n    return message\n  }\n\n  private parseErrorMessage(offset: number, length: number, bytes: Buffer, name: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const fields: Record<string, string> = {}\n    let fieldType = this.reader.string(1)\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring()\n      fieldType = this.reader.string(1)\n    }\n\n    const messageValue = fields.M\n\n    const message =\n      name === 'notice' ? new NoticeMessage(length, messageValue) : new DatabaseError(messageValue, length, name)\n\n    message.severity = fields.S\n    message.code = fields.C\n    message.detail = fields.D\n    message.hint = fields.H\n    message.position = fields.P\n    message.internalPosition = fields.p\n    message.internalQuery = fields.q\n    message.where = fields.W\n    message.schema = fields.s\n    message.table = fields.t\n    message.column = fields.c\n    message.dataType = fields.d\n    message.constraint = fields.n\n    message.file = fields.F\n    message.line = fields.L\n    message.routine = fields.R\n    return message\n  }\n}\n"]},"metadata":{},"sourceType":"script"}